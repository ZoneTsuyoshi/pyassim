<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>pyassim</title>
        <meta name="description" content="support page for data assimilation python package pyassim">
        <meta name="author" content="Tsuyoshi Ishizone">
        <!-- <link rel="shortcut icon" href="figs/tennis.jpg" type="image/x-icon"> -->

        <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
        </script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: { equationNumbers: { autoNumber: "AMS" }},
                tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                processEscapes: true
                },
                "HTML-CSS": { matchFontHeight: false },
                displayAlign: "left",
                displayIndent: "2em"
            });
        </script>

        <!-- <link rel="stylesheet" href="https://unpkg.com/ress/dist/ress.min.css"> -->
        <!-- <link rel="stylesheet" href="css/style.css"> -->
        <link rel="stylesheet" href="css/default.css" type="text/css" />
        <link rel="stylesheet" href="css/pygments.css" type="text/css" />
        <link rel="top" title="pyassim 0.0.11 documentation" href="#" />
    </head>

    <body>
        <div class="document">
            <div class="documentwrapper">
                <div class="bodywrapper">
                    <div class="body">
                        <h1>pyassim</h1>

                        <div class="section" id="installation">
                        <h2 id="install">How to Install</h2>
                        <p>For a quick installation::</p>
                        <pre>
                            <code><br>$ pip install pyassim<br> </code>
                        </pre>
                        <p>or</p>
                        <pre>
                            <code><br>$ easy_install pyassim<br> </code>
                        </pre>
                        <p>Alternatively, you can get the latest and greatest from 
                            <a href="https://github.com/ZoneTsuyoshi/pyassim/tree/master">GitHub::</a>
                        </p>
                        <div class="highlight-python"><pre>
                $ git clone https://github.com/ZoneTsuyoshi/pyassim.git
                $ cd pyassim
                $ sudo python setup.py install
                        </pre></div>
                        <p>
                            <code>pyassim</code> depends on following packages:
                        </p>
                        <ul>
                            <li><code>numpy >= 1.13.3</code> (for core functionality)</li>
                            <li><code>cupy</code> (for gpu calculation. This package is not automatically installed as dependencies)</li>
                        </ul></div>



                        <h2>How to Use</h2>
                        <p>
                            <code>pyassim</code> provides easy implementation for following methods:
                        </p>
                        <table>
                            <thead>
                                <tr>
                                    <th>Class</th>
                                    <th>Method</th>
                                    <th>Paper Link</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><a href="#kf">KalmanFilter</a></td>
                                    <td>Kalman Filter (KF)</td>
                                    <td><a href="https://asmedigitalcollection.asme.org/fluidsengineering/article-abstract/82/1/35/397706/A-New-Approach-to-Linear-Filtering-and-Prediction?redirectedFrom=fulltext">ASME</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#enkf">EnsembleKalmanFilter</a></td>
                                    <td rowspan="2">Ensemble KF (EnKF)</td>
                                    <td rowspan="2"><a href="https://link.springer.com/article/10.1007/s10236-003-0036-9">SpringerLink</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#nenkf">NonlinearEnsembleKalmanFilter</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#letkf">LocalEnsembleTransformKalmanFilter</a></td>
                                    <td>Local Ensemble Transform KF (LETKF)</td>
                                    <td><a href="https://www.sciencedirect.com/science/article/pii/S0167278906004647">ScienceDirect</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#pf">ParticleFilter</a></td>
                                    <td>Particle Filter (PF)</td>
                                    <td><a href="https://www.jstor.org/stable/1390750?seq=1#metadata_info_tab_contents">JSTOR</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#gpfg">GaussianParticleFilterGauss</a></td>
                                    <td>Gaussian PF (GPF)</td>
                                    <td><a href="https://ieeexplore.ieee.org/document/1232326">IEEE</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#gvmpf">GaussianVariationalMappingParticleFilter</a></td>
                                    <td>Variational Mapping PF (VMPF)</td>
                                    <td><a href="https://arxiv.org/abs/1805.11380">arXiv</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#lock">LOCK</a></td>
                                    <td>Linear Opeartor Construction with the KF (LOCK)</td>
                                    <td rowspan="3"><a href="https://arxiv.org/abs/2001.11256">arXiv</a></td>
                                </tr>
                                <tr>
                                    <td><a href="#llock">LocalLOCK</a></td>
                                    <td>Local LOCK (LLOCK)</td>
                                </tr>
                                <tr>
                                    <td><a href="#slock">SpatiallyUniformLOCK</a></td>
                                    <td>Spatially Uniform LOCK (SLOCK)</td>
                                </tr>
                                <tr>
                                    <td><a href="#lslock">LSLOCK</a></td>
                                    <td>Locally and Spatially Uniform LOCK (LSLOCK)</td>
                                    <td><a href="https://link.springer.com/chapter/10.1007/978-3-030-58653-9_33">SpringerLink</a></td>
                                </tr>
                            </tbody>
                        </table>


                        <h3 id="kf">KalmanFilter</h3>
                        <code>
                            KalmanFilter(observation = None,
                                initial_mean = None, initial_covariance = None,
                                transition_matrices = None, observation_matrices = None,
                                transition_covariance = None, observation_covariance = None,
                                transition_noise_matrices = None,
                                transition_offsets = None, observation_offsets = None,
                                transition_observation_covariance = None,
                                em_vars = ['transition_covariance', 'observation_covariance',
                                'initial_mean', 'initial_covariance'],
                                transition_covariance_structure = 'all',
                                observation_covariance_structure = 'all',
                                transition_vh_length = None,
                                observation_vh_length = None, 
                                n_dim_sys = None, n_dim_obs = None, dtype = "float32",
                                xp_type = "numpy")
                        </code>
                        <h4>Mathematical Notation</h4>
                        <p>This class assumes linear Gaussian state space model</p>
                        \begin{align*}
                            x_{t+1}   &= F_{t} x_{t} + b_{t} + G_{t} v_{t}, \\
                            y_{t}     &= H_{t} x_{t} + d_{t} + w_{t}, \\
                            [v_{t}, w_{t}]^T &\sim N\left(0, \begin{pmatrix} Q_{t} & S_{t}^T \\ S_{t} & R_{t} \end{pmatrix}\right),
                        \end{align*}
                        where $x_t, b_t\in\mathbb{R}^{N_x}$, $y_t, d_t\in\mathbb{R}^{N_y}$, and $v_t\in\mathbb{R}^{N_v}$.
                        <h4>Arguments</h4>
                        <ul>
                            <li>observation: ndarray of shape $(T,N_y)$<br>
                                Observation values $\{y_t\}_{t=1}^T$.</li>
                            <li>initial_mean: ndarray of shape $(N_x)$<br>
                                Initial state mean $x_1\in\mathbb{R}^{N_x}$</li>
                            <li>initial_covariance: ndarray of shape $(N_x,N_x)$<br>
                                Initial state covariance $V_1=\mathrm{Cov}(x_1,x_1)\in\mathbb{R}^{N_x\times N_x}$</li>
                            <li>transition_matrices: ndarray of shape $(T-1,N_x,N_x)$ or $(N_x,N_x)$<br>
                                Transition matrices $\{F_t\}_{t=1}^{T-1}$.
                                If input shape is $(N_x,N_x)$, transition matrix is time-invariant $F\in\mathbb{R}^{N_x,N_x}$.
                                Default value is time-invariant identity matrix $F=I$</li>
                            <li>observation_matrices: ndarray of shape $(T,N_y,N_x)$ or $(N_y,N_x)$<br>
                                Observation matrices $\{H_t\}_{t=1}^{T}$.
                                If input shape is $(N_y,N_x)$, observation matrix is time-invariant $H\in\mathbb{R}^{N_y,N_x}$.
                                Default value is time-invariant identity matrix $H=I$</li>
                            <li>transition_covariance: ndarray of shape $(T-1,N_v,N_v)$ or $(N_v,N_v)$<br>
                                Transition covariance $\{Q_t\}_{t=1}^{T-1}$.
                                If input shape is $(N_v,N_v)$, transition covariance is time-invariant $Q\in\mathbb{R}^{N_v,N_v}$.
                                Default value is time-invariant identity matrix $Q=I$</li>
                            <li>observation_covariance: ndarray of shape $(T,N_y,N_y)$ or $(N_y,N_y)$<br>
                                Observation covariance $\{R_t\}_{t=1}^{T}$.
                                If input shape is $(N_y,N_y)$, observation covariance is time-invariant $R\in\mathbb{R}^{N_y,N_y}$.
                                Default value is time-invariant identity matrix $R=I$</li>
                            <li>transition_noise_matrices: ndarray of shape $(T-1,N_x,N_v)$ or $(N_x,N_v)$<br>
                                Transition noise matrices $\{G_t\}_{t=1}^{T-1}$.
                                If input shape is $(N_x,N_v)$, transition matrix is time-invariant $G\in\mathbb{R}^{N_x,N_v}$.
                                Default value is time-invariant identity matrix $G=I$.
                                If this argument is None, the noise dimension $N_v=N_x$</li>
                            <li>transition_offsets: ndarray of shape $(T-1,N_x)$ or $(N_x,)$<br>
                                Transition offset vectors $\{b_t\}_{t=1}^{T-1}$.
                                If input shape is $(N_x)$, transition offset is time-invariant $b\in\mathbb{R}^{N_x}$.
                                Default value is time-invariant zero vector $b=0$</li>
                            <li>observation_offsets: ndarray of shape $(T,N_y)$ or $(N_y,)$<br>
                                Observation offset vectors $\{d_t\}_{t=1}^{T}$.
                                If input shape is $(N_y)$, observation offset is time-invariant $d\in\mathbb{R}^{N_y}$.
                                Default value is time-invariant zero vector $d=0$</li>
                            <li>transition_observation_covariance: ndarray of shape $(T,N_y,N_v)$ or $(N_y,N_v)$<br>
                                Transition observation covariance $\{S_t\}_{t=1}^{T-1}$.
                                If input shape is $(N_y,N_v)$, transition observation covariance is time-invariant $S\in\mathbb{R}^{N_y,N_v}$.
                                Default value is time-invariant zero matrix $S=O$</li>
                            <li>em_vars: list<br>
                                Learning variables in EM algorithm.
                                Subset of ["transition_matrices", "observation_matrices", "transition_offsets", "observation_offsets", 
                                "transition_covariance", "observation_covariance", "initial_mean", "initial_covariance"]</li>
                            <li>transition_covariance_structure: {"all", "triD1", "triD2"}, default=all<br>
                                Covariance structure for transition matrix in EM algorithm.
                                All elements of the matrix are optimized if "all", while tridiagonal elements are only optimized for systems in 1/2 dimensional lattice space if "triD1" or "tri2D", respectively.</li>
                            <li>observation_covariance_structure: {"all", "triD1", "triD2"}, default=all<br>
                                Covariance structure for observation matrix in EM algorithm.
                                All elements of the matrix are optimized if "all", while tridiagonal elements are only optimized for observations in 1/2 dimensional lattice space if "triD1" or "tri2D", respectively.</li>
                            <li>transition_vh_length: [int, int]<br>
                                The first element is the number of vertical lattice points if system variables are 2-dimensional lattice.
                                The second element is the number of horizontal lattice points if system variables are 2-dimensional lattice.</li>
                            <li>transition_vh_length: [int, int]<br>
                                The first element is the number of vertical lattice points if system variables are 2-dimensional lattice.
                                The second element is the number of horizontal lattice points if system variables are 2-dimensional lattice.</li>
                            <li>observation_vh_length: [int, int]<br>
                                The first element is the number of vertical lattice points if observation variables are 2-dimensional lattice.
                                The second element is the number of horizontal lattice points if observation variables are 2-dimensional lattice.</li>
                            <li>n_dim_sys: int<br>
                                Dimension of system variabels $N_x$.
                                If None, this argument is automatically determined by transition_matrices, transition_offsets, transition_noise_matrices, initial_mean, initial_covariance, observation_matrices, and transition_observation_covariance.</li>
                            <li>n_dim_obs: int<br>
                                Dimension of observation variables $N_y$.
                                If None, this argument is automatically determined by observation_matrices, observation_offsets, observation_covariance, and transition_observation_covariance.</li>
                            <li>dtype: {"float32", "float64"}<br>
                                Data type of ndarray.</li>
                            <li>xp_type: {"numpy", "cupy"}<br>
                                Pacakge name for array computation.</li>
                        </ul>
                        <h4>Functions</h4>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>