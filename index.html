<!doctype html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>pyassim</title>
        <meta name="description" content="support page for data assimilation python package pyassim">
        <meta name="author" content="Tsuyoshi Ishizone">
        <!-- <link rel="shortcut icon" href="figs/tennis.jpg" type="image/x-icon"> -->

        <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
        </script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: { equationNumbers: { autoNumber: "AMS" }},
                tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                processEscapes: true
                },
                "HTML-CSS": { matchFontHeight: false },
                displayAlign: "left",
                displayIndent: "2em"
            });
        </script>

        <!-- <link rel="stylesheet" href="https://unpkg.com/ress/dist/ress.min.css"> -->
        <!-- <link rel="stylesheet" href="css/style.css"> -->
        <link rel="stylesheet" href="css/default.css" type="text/css" />
        <link rel="stylesheet" href="css/pygments.css" type="text/css" />
        <link rel="top" title="pyassim 0.0.11 documentation" href="#" />
    </head>

    <body>
    <div class="document">
    <div class="documentwrapper">
    <div class="bodywrapper">
    <div class="body">
        <h1>pyassim</h1>

        <div class="section" id="installation">
        <h2 id="install">How to Install</h2>
        <p>For a quick installation::</p>
        <div class="highlight-python"><pre>
$ pip install pyassim</pre>
        </div>
        <p>or</p>
        <div class="highlight-python"><pre>
$ easy_install pyassim</pre>
        </div>
        <p>Alternatively, you can get the latest and greatest from 
            <a href="https://github.com/ZoneTsuyoshi/pyassim/tree/master">GitHub::</a>
        </p>
        <div class="highlight-python"><pre>
$ git clone https://github.com/ZoneTsuyoshi/pyassim.git
$ cd pyassim
$ sudo python setup.py install</pre>
        </div>
        <p>
            <code>pyassim</code> depends on following packages:
        </p>
        <ul>
            <li><code>numpy >= 1.13.3</code> (for core functionality)</li>
            <li><code>cupy</code> (for gpu calculation. This package is not automatically installed as dependencies)</li>
        </ul></div>



        <h2>How to Use</h2>
        <p>
            <code>pyassim</code> provides easy implementation for following methods:
        </p>
        <table border="1" class="longtable docutils">
            <thead>
                <tr>
                    <th>Class</th>
                    <th>Method</th>
                    <th>Paper Link</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><a href="#kf">KalmanFilter</a></td>
                    <td>Kalman Filter (KF)</td>
                    <td><a href="https://asmedigitalcollection.asme.org/fluidsengineering/article-abstract/82/1/35/397706/A-New-Approach-to-Linear-Filtering-and-Prediction?redirectedFrom=fulltext">ASME</a></td>
                </tr>
                <tr>
                    <td><a href="#enkf">EnsembleKalmanFilter</a></td>
                    <td rowspan="2">Ensemble KF (EnKF)</td>
                    <td rowspan="2"><a href="https://link.springer.com/article/10.1007/s10236-003-0036-9">SpringerLink</a></td>
                </tr>
                <tr>
                    <td><a href="#nenkf">NonlinearEnsembleKalmanFilter</a></td>
                </tr>
                <tr>
                    <td><a href="#letkf">LocalEnsembleTransformKalmanFilter</a></td>
                    <td>Local Ensemble Transform KF (LETKF)</td>
                    <td><a href="https://www.sciencedirect.com/science/article/pii/S0167278906004647">ScienceDirect</a></td>
                </tr>
                <tr>
                    <td><a href="#pf">ParticleFilter</a></td>
                    <td>Particle Filter (PF)</td>
                    <td><a href="https://www.jstor.org/stable/1390750?seq=1#metadata_info_tab_contents">JSTOR</a></td>
                </tr>
                <tr>
                    <td><a href="#gpfg">GaussianParticleFilterGauss</a></td>
                    <td>Gaussian PF (GPF)</td>
                    <td><a href="https://ieeexplore.ieee.org/document/1232326">IEEE</a></td>
                </tr>
                <tr>
                    <td><a href="#gvmpf">GaussianVariationalMappingParticleFilter</a></td>
                    <td>Variational Mapping PF (VMPF)</td>
                    <td><a href="https://arxiv.org/abs/1805.11380">arXiv</a></td>
                </tr>
                <tr>
                    <td><a href="#lock">LOCK</a></td>
                    <td>Linear Opeartor Construction with the KF (LOCK)</td>
                    <td rowspan="3"><a href="https://arxiv.org/abs/2001.11256">arXiv</a></td>
                </tr>
                <tr>
                    <td><a href="#llock">LocalLOCK</a></td>
                    <td>Local LOCK (LLOCK)</td>
                </tr>
                <tr>
                    <td><a href="#slock">SpatiallyUniformLOCK</a></td>
                    <td>Spatially Uniform LOCK (SLOCK)</td>
                </tr>
                <tr>
                    <td><a href="#lslock">LSLOCK</a></td>
                    <td>Locally and Spatially Uniform LOCK (LSLOCK)</td>
                    <td><a href="https://link.springer.com/chapter/10.1007/978-3-030-58653-9_33">SpringerLink</a></td>
                </tr>
            </tbody>
        </table>


        <h3 id="kf">KalmanFilter</h3>
        <dt><p>
            KalmanFilter(observation = None,
                initial_mean = None, initial_covariance = None,
                transition_matrices = None, observation_matrices = None,
                transition_covariance = None, observation_covariance = None,
                transition_noise_matrices = None,
                transition_offsets = None, observation_offsets = None,
                transition_observation_covariance = None,
                em_vars = ['transition_covariance', 'observation_covariance',
                'initial_mean', 'initial_covariance'],
                transition_covariance_structure = 'all',
                observation_covariance_structure = 'all',
                transition_vh_length = None,
                observation_vh_length = None, 
                n_dim_sys = None, n_dim_obs = None, dtype = "float32",
                xp_type = "numpy")
        </p></dt>
        <dd>
        <p>This class assumes linear Gaussian state space model</p>
        \begin{align*}
            x_{t+1}   &= F_{t} x_{t} + b_{t} + G_{t} v_{t}, \\
            y_{t}     &= H_{t} x_{t} + d_{t} + w_{t}, \\
            [v_{t}, w_{t}]^T &\sim N\left(0, \begin{pmatrix} Q_{t} & S_{t}^T \\ S_{t} & R_{t} \end{pmatrix}\right),
        \end{align*}
        where $x_t, b_t\in\mathbb{R}^{N_x}$, $y_t, d_t\in\mathbb{R}^{N_y}$, and $v_t\in\mathbb{R}^{N_v}$.
        <table class="docutils field-list" frame="void" rules="none">
        <col class="field-name" />
        <col class="field-body" />
        <tbody valign="top">
        <tr class="field-odd field">
            <th class="field-name">Parameters: </th>
            <td class="field-body">
            <p class="first"><b>observation: ndarray of shape $(T,N_y)$</b></p>
                <blockquote><div><p>
                Observation values $\{y_t\}_{t=1}^T$.
                </p></div></blockquote>
            <p><b>initial_mean: ndarray of shape $(N_x)$</b></p>
                <blockquate><div><p>
                Initial state mean $x_1\in\mathbb{R}^{N_x}$</p></div></blockquate>
            <p><b>initial_covariance: ndarray of shape $(N_x,N_x)$</b></p>
                <blockquate><div><p>
                Initial state covariance $V_1=\mathrm{Cov}(x_1,x_1)\in\mathbb{R}^{N_x\times N_x}$</p></div></blockquate>
            <p><b>transition_matrices: ndarray of shape $(T-1,N_x,N_x)$ or $(N_x,N_x)$</b></p>
                <blockquate><div><p>
                Transition matrices $\{F_t\}_{t=1}^{T-1}$.
                If input shape is $(N_x,N_x)$, transition matrix is time-invariant $F\in\mathbb{R}^{N_x,N_x}$.
                Default value is time-invariant identity matrix $F=I$</p></div></blockquate>
            <p><b>observation_matrices: ndarray of shape $(T,N_y,N_x)$ or $(N_y,N_x)$</b></p>
                <blockquate><div><p>
                Observation matrices $\{H_t\}_{t=1}^{T}$.
                If input shape is $(N_y,N_x)$, observation matrix is time-invariant $H\in\mathbb{R}^{N_y,N_x}$.
                Default value is time-invariant identity matrix $H=I$</p></div></blockquate>
            <p><b>transition_covariance: ndarray of shape $(T-1,N_v,N_v)$ or $(N_v,N_v)$</b></p>
                <blockquate><div><p>
                Transition covariance $\{Q_t\}_{t=1}^{T-1}$.
                If input shape is $(N_v,N_v)$, transition covariance is time-invariant $Q\in\mathbb{R}^{N_v,N_v}$.
                Default value is time-invariant identity matrix $Q=I$</p></div></blockquate>
            <p><b>observation_covariance: ndarray of shape $(T,N_y,N_y)$ or $(N_y,N_y)$</b></p>
                <blockquate><div><p>
                Observation covariance $\{R_t\}_{t=1}^{T}$.
                If input shape is $(N_y,N_y)$, observation covariance is time-invariant $R\in\mathbb{R}^{N_y,N_y}$.
                Default value is time-invariant identity matrix $R=I$</p></div></blockquate>
            <p><b>transition_noise_matrices: ndarray of shape $(T-1,N_x,N_v)$ or $(N_x,N_v)$</b></p>
                <blockquate><div><p>
                Transition noise matrices $\{G_t\}_{t=1}^{T-1}$.
                If input shape is $(N_x,N_v)$, transition matrix is time-invariant $G\in\mathbb{R}^{N_x,N_v}$.
                Default value is time-invariant identity matrix $G=I$.
                If this argument is None, the noise dimension $N_v=N_x$</p></div></blockquate>
            <p><b>transition_offsets: ndarray of shape $(T-1,N_x)$ or $(N_x,)$</b></p>
                <blockquate><div><p>
                Transition offset vectors $\{b_t\}_{t=1}^{T-1}$.
                If input shape is $(N_x)$, transition offset is time-invariant $b\in\mathbb{R}^{N_x}$.
                Default value is time-invariant zero vector $b=0$</p></div></blockquate>
            <p><b>observation_offsets: ndarray of shape $(T,N_y)$ or $(N_y,)$</b></p>
                <blockquate><div><p>
                Observation offset vectors $\{d_t\}_{t=1}^{T}$.
                If input shape is $(N_y)$, observation offset is time-invariant $d\in\mathbb{R}^{N_y}$.
                Default value is time-invariant zero vector $d=0$</p></div></blockquate>
            <p><b>transition_observation_covariance: ndarray of shape $(T,N_y,N_v)$ or $(N_y,N_v)$</b></p>
                <blockquate><div><p>
                Transition observation covariance $\{S_t\}_{t=1}^{T-1}$.
                If input shape is $(N_y,N_v)$, transition observation covariance is time-invariant $S\in\mathbb{R}^{N_y,N_v}$.
                Default value is time-invariant zero matrix $S=O$</p></div></blockquate>
            <p><b>em_vars: list</b></p>
                <blockquate><div><p>
                Learning variables in EM algorithm.
                Subset of ["transition_matrices", "observation_matrices", "transition_offsets", "observation_offsets", 
                "transition_covariance", "observation_covariance", "initial_mean", "initial_covariance"]</p></div></blockquate>
            <p><b>transition_covariance_structure: {"all", "triD1", "triD2"}, default=all</b></p>
                <blockquate><div><p>
                Covariance structure for transition matrix in EM algorithm.
                All elements of the matrix are optimized if "all", while tridiagonal elements are only optimized for systems in 1/2 dimensional lattice space if "triD1" or "tri2D", respectively.</p></div></blockquate>
            <p><b>observation_covariance_structure: {"all", "triD1", "triD2"}, default=all</b></p>
                <blockquate><div><p>
                Covariance structure for observation matrix in EM algorithm.
                All elements of the matrix are optimized if "all", while tridiagonal elements are only optimized for observations in 1/2 dimensional lattice space if "triD1" or "tri2D", respectively.</p></div></blockquate>
            <p><b>transition_vh_length: [int, int]</b></p>
                <blockquate><div><p>
                The first element is the number of vertical lattice points if system variables are 2-dimensional lattice.
                The second element is the number of horizontal lattice points if system variables are 2-dimensional lattice.</p></div></blockquate>
            <p><b>transition_vh_length: [int, int]</b></p>
                <blockquate><div><p>
                The first element is the number of vertical lattice points if system variables are 2-dimensional lattice.
                The second element is the number of horizontal lattice points if system variables are 2-dimensional lattice.</p></div></blockquate>
            <p><b>observation_vh_length: [int, int]</b></p>
                <blockquate><div><p>
                The first element is the number of vertical lattice points if observation variables are 2-dimensional lattice.
                The second element is the number of horizontal lattice points if observation variables are 2-dimensional lattice.</p></div></blockquate>
            <p><b>n_dim_sys: int</b></p>
                <blockquate><div><p>
                Dimension of system variabels $N_x$.
                If None, this argument is automatically determined by transition_matrices, transition_offsets, transition_noise_matrices, initial_mean, initial_covariance, observation_matrices, and transition_observation_covariance.</p></div></blockquate>
            <p><b>n_dim_obs: int</b></p><blockquate>
                <div><p>
                Dimension of observation variables $N_y$.
                If None, this argument is automatically determined by observation_matrices, observation_offsets, observation_covariance, and transition_observation_covariance.</p></div></blockquate>
            <p><b>dtype: {"float32", "float64"}</b></p>
                <blockquate><div><p>
                Data type of ndarray.
                </p></div></blockquate>
            <p><b>xp_type: {"numpy", "cupy"}</b></p>
                <blockquate class="last"><div><p>
                Pacakge name for array computation.
                </p></div></blockquate>
            </td>
        </tr></tbody></table>
        <p class="rubric">Methods</p>
        <table border="0" class="longtable docutils">
            <colgroup>
                <col width="10%" />
                <col width="90%" />
            </colgroup>
        <tbody valign="top">
            <tr class="row-odd">
                <td><a class="reference internal" href="#kf.forward" title="kf.forward"><span class="pre">forward</span></a>([y])</td>
                <td>Apply the Kalman filter</td>
            </tr>
            <tr class="row-even">
                <td><a class="reference internal" href="#kf.smooth" title="kf.smooth"><span class="pre">smooth</span></a>([y])</td>
                <td>Apply the RTS smoother</td>
            </tr>
            <tr class="row-odd">
                <td><a class="reference internal" href="#kf.fixed_lag_smooth" title="kf.fixed_lag_smooth"><span class="pre">fixed_lag_smooth</span></a>(L,[y])</td>
                <td>Apply the fixed lag Kalman smoother</td>
            </tr>
            <tr class="row-even">
                <td><a class="reference internal" href="#kf.em" title="kf.em"><span class="pre">em</span></a>(n_iter, [em_vars, ...])</td>
                <td>Apply the EM algorithm</td>
            </tr>
            <tr class="row-odd">
                <td><a class="reference internal" href="#kf.get_predicted_value" title="kf.get_predicted_value"><span class="pre">get_predicted_value</span></a>([dim])</td>
                <td>Get the predicted state estimates</td>
            </tr>
            <tr class="row-even">
                <td><a class="reference internal" href="#kf.get_filtered_value" title="kf.get_filtered_value"><span class="pre">get_filtered_value</span></a>([dim])</td>
                <td>Get the filtered state estimates</td>
            </tr>
            <tr class="row-odd">
                <td><a class="reference internal" href="#kf.get_smoothed_value" title="kf.get_smoothed_value"><span class="pre">get_smoothed_value</span></a>([dim])</td>
                <td>Get the smoothed state estimates</td>
            </tr>
        </tbody>
        </table>
        </dd>



        <h3 id="enkf">EnsembleKalmanFilter</h3>
        <dt><p>
            KalmanFilter(observation = None, transition_functions = None,
                observation_matrices = None, initial_mean = None,
                initial_covariance = None,
                transition_noise = None, observation_covariance = None,
                n_dim_sys = None, n_dim_obs = None, dtype = "float32",
                xp_type = "numpy", seed = 0)
        </p></dt>

        <dd>
        <p>This class assumes following state space model</p>
        \begin{align*}
            x_{t+1}   &= f_{t} (x_{t}, v_{t}), \\
            y_{t}     &= H_{t} x_{t} + w_{t}, \\
            v_{t}     &\sim p_v(v_{t}),\\
            w_{t}     &\sim N(0, R_t) 
        \end{align*}
        where $x_t, v_t\in\mathbb{R}^{N_x}$, $y_t, w_t\in\mathbb{R}^{N_y}$.

        <table class="docutils field-list" frame="void" rules="none">
        <col class="field-name" />
        <col class="field-body" />
        <tbody valign="top">
        <tr class="field-odd field">
            <th class="field-name">Parameters: </th>
            <td class="field-body">
            <p class="first"><b>observation: ndarray of shape $(T,N_y)$</b></p>
                <blockquote><div><p>
                Observation values $\{y_t\}_{t=1}^T$.
                </p></div></blockquote>
            <p><b>transition_functions: list of functions or a function</b></p>
                <blockquate><div><p>
                Transition functions $\{f_t(\cdot,\cdot)\}_{t=1}^{T}$.
                If input type is function, transition function is time-invariant $f$.
                Default value is time-invariant random walk $f(x,v)=x+v$</p></div></blockquate>
            <p><b>observation_matrices: ndarray of shape $(T,N_y,N_x)$ or $(N_y,N_x)$</b></p>
                <blockquate><div><p>
                Observation matrices $\{H_t\}_{t=1}^{T}$.
                If input shape is $(N_y,N_x)$, observation matrix is time-invariant $H\in\mathbb{R}^{N_y,N_x}$.
                Default value is time-invariant identity matrix $H=I$</p></div></blockquate>
            <p><b>initial_mean: ndarray of shape $(N_x)$</b></p>
                <blockquate><div><p>
                Initial state mean $x_1\in\mathbb{R}^{N_x}$</p></div></blockquate>
            <p><b>initial_covariance: ndarray of shape $(N_x,N_x)$</b></p>
                <blockquate><div><p>
                Initial state covariance $V_1=\mathrm{Cov}(x_1,x_1)\in\mathbb{R}^{N_x\times N_x}$</p></div></blockquate>
            <p><b>transition_noise: [function, list of parameters for function]</b></p>
                <blockquate><div><p>
                The first element is the transition distribution $\{p_v(\cdot)\}$.
                This default value is ``numpy.random.multivariate_normal" function.
                The second element is the parameters of the distribution.
                This default value is [$\mathbf{0}_{N_x}$, $I_{N_x}$].</p></div></blockquate>
            <p><b>observation_covariance: ndarray of shape $(T,N_y,N_y)$ or $(N_y,N_y)$</b></p>
                <blockquate><div><p>
                Observation covariance $\{R_t\}_{t=1}^{T}$.
                If input shape is $(N_y,N_y)$, observation covariance is time-invariant $R\in\mathbb{R}^{N_y,N_y}$.
                Default value is time-invariant identity matrix $R=I$</p></div></blockquate>
            <p><b>n_dim_sys: int</b></p>
                <blockquate><div><p>
                Dimension of system variabels $N_x$.
                If None, this argument is automatically determined by initial_mean, initial_covariance, and observation_matrices.</p></div></blockquate>
            <p><b>n_dim_obs: int</b></p><blockquate>
                <div><p>
                Dimension of observation variables $N_y$.
                If None, this argument is automatically determined by observation_matrices and observation_covariance.</p></div></blockquate>
            <p><b>dtype: {"float32", "float64"}</b></p>
                <blockquate><div><p>
                Data type of ndarray.
                </p></div></blockquate>
            <p><b>xp_type: {"numpy", "cupy"}</b></p>
                <blockquate><div><p>
                Pacakge name for array computation.
                </p></div></blockquate>
            <p><b>seed: int</b></p>
                <blockquate class="last"><div><p>
                Determines random number generation for sampling noise.
                </p></div></blockquate>
            </td>
        </tr></tbody></table>
        <p class="rubric">Methods</p>
        <table border="0" class="longtable docutils">
            <colgroup>
                <col width="10%" />
                <col width="90%" />
            </colgroup>
        <tbody valign="top">
            <tr class="row-odd">
                <td><a class="reference internal" href="#enkkf.forward" title="enkf.forward"><span class="pre">forward</span></a>([y])</td>
                <td>Apply the ensemble Kalman filter</td>
            </tr>
            <tr class="row-even">
                <td><a class="reference internal" href="#enkf.smooth" title="enkf.smooth"><span class="pre">smooth</span></a>(L,[y])</td>
                <td>Apply the fixed lag ensemble Kalman smoother</td>
            </tr>
            <tr class="row-odd">
                <td><a class="reference internal" href="#enkf.get_predicted_value" title="enkf.get_predicted_value"><span class="pre">get_predicted_value</span></a>([dim])</td>
                <td>Get the predicted state estimates</td>
            </tr>
            <tr class="row-even">
                <td><a class="reference internal" href="#enkf.get_filtered_value" title="enkf.get_filtered_value"><span class="pre">get_filtered_value</span></a>([dim])</td>
                <td>Get the filtered state estimates</td>
            </tr>
            <tr class="row-odd">
                <td><a class="reference internal" href="#enkf.get_smoothed_value" title="enkf.get_smoothed_value"><span class="pre">get_smoothed_value</span></a>([dim])</td>
                <td>Get the smoothed state estimates</td>
            </tr>
        </tbody>
        </table>
        </dd>
    </div>
    </div>
    </div>
    </div>
    </body>
</html>